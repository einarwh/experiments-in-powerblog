<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><title>Mkay: One validation attribute to rule them all | @einarwh</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="Mkay: One validation attribute to rule them all"><meta property="og:url" content="https://www.example.com/blog-posts/mkay-one-validation-attribute-to-rule-them-all/"><link rel="stylesheet" href="/bundles/c5b7698bdf4e/app.css"></head><body><header><a href="/">@einarwh</a></header><h1>Mkay: One validation attribute to rule them all</h1>
<p>Posted: February 15, 2013</p>
<p>If you’ve ever created an ASP.NET MVC application, chances are you’ve used data annotation validators to validate user input to your models. They’re <em>nice</em>, aren’t they? They’re so easy to use, they’re almost like magic. You simply annotate your properties with some declarative constraint, and the good djinns of the framework provide both client-side validation and server-side validation for you. Out of thin air! The client-side validation is implemented in JavaScript and gives rapid feedback to the user during data entry, whereas the server-side validation is implemented in .NET and ensures that the data is valid even if the user should circumvent the client-side validation somehow (an obvious approach would be to disable JavaScript in the browser). Magical.</p>
<p>The only problem with data annotation validators is that they are pretty limited in their semantics. The built-in validation attributes only cover a few of the most common, basic use cases. For instance, you can use the <strong>[Required]</strong> attribute to ensure that a property is given a value, the <strong>[Range]</strong> attribute to specify that the property of a value must be between two constant values, or the <strong>[RegularExpression]</strong> attribute to specify a regular expression that a string property must match. That’s all well and good, but not really suited for sophisticated validation. In case you have stronger constraints or invariants for your data model, you must reach for one of two solutions. You can use the <strong>[Remote]</strong> attribute, which allows you to do arbitrary validation at the server. In that case, however, you’re doing faux-client-side validation. What really happens behind the scenes is that you fire off an AJAX call to the server. The alternative is to implement your own custom validation attribute, and write validation logic in both .NET and in JavaScript. However, that quickly becomes tiresome. While your custom attribute certainly can do arbitrary model validation, you’ve ended up doing the work that the djinns should be doing for you. There is no magic any more, there is just grunt work. The spell is broken.</p>
<p>Wouldn’t it be terribly nifty if there were some way to just express your sophisticated rules and constraints declaratively as intended, and have someone else do all the hard work? That’s what I thought, too. At this point, you shouldn’t be terribly surprised to learn that such a validation attribute does, in fact, exist. I’ve made it myself. The attribute is called Mkay, and supports a simple rule DSL for expressing pretty much arbitrary constraints on property values using a LISP-like syntax. Why LISP, you ask? For three obvious reasons:</p>
<ol>
<li>LISP syntax is super-easy to parse.</li>
<li>Any excuse to shoe-horn LISP-like expressions into a string is a good one.</li>
<li>LISP syntax is super-easy to parse.</li>
</ol>
<p>So that’s the syntax, but exactly what kinds of rules can you express using the Mkay rule DSL? Well, that’s pretty much up to you – that’s the whole point, after all. In an Mkay expression, you can have constant values, property access (to any property on the model), logical operators (<em>and</em> and <em>or</em>), comparison operators (<em>equality</em>, <em>greater-than</em>, <em>less-than</em> and so forth), arithmetic, and a handful of simple functions (such as <em>len</em> for string length, <em>max</em> for selecting max value, <em>now</em> for the current time etc). It’s not too hard to extend it to support additional functions, but obviously they must then be implemented/wired up in JavaScript and .NET code. A contrived example should make it clearer:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="na">  [Mkay("(&lt; (len .) 5)", ErrorMessage = "That's too long, my friend.")]</span>
  <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="na"> </span>
<span class="na">  [Mkay("(&gt;= . \"31.01.1900\")")]</span>
  <span class="k">public</span> <span class="n">DateTime</span> <span class="n">BirthDate</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="na"> </span>
<span class="na">  [Mkay("(&lt;= . (now))")]</span>
  <span class="k">public</span> <span class="n">DateTime</span> <span class="n">DeathDate</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="na"> </span>
<span class="na">  [Mkay("(and (&gt;= . BirthDate) (&lt;= . DeathDate))")]</span>
  <span class="k">public</span> <span class="n">DateTime</span> <span class="n">LastSeen</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In case it’s not terribly obvious, the rules indicate that the length of the <strong>Name</strong> property must be less than <em>10</em>, the <strong>BirthDate</strong> must be later than <em>31.01.1900</em>, the <strong>DeathDate</strong> must be before the current date, and <strong>LastSeen</strong> must understandably be some time between birth and death. Makes sense?</p>
<p>If you’ve never seen a LISP expression before, note that LISP operators are put in front of, rather than in between, the values they operate on. This is known as prefix notation as opposed to infix notation (or postfix notation, where the operator comes at the end). An expression like “(&lt; . (now))” should be interpreted as “the value of the <strong>DeathDate</strong> property should be less than the value of (now)”. From this, you might deduce (correctly) that “.” is used as shorthand for the name of the property being validated. This is the first of three spoonfuls of syntactic sugar employed by Mkay to simplify the syntax for validation rules. The second spoonful is implicit “.” for comparisons, which means that you can actually write “(&lt; (now))” instead of “(&lt; . (now))”. And finally, the third spoonful lets you drop the outermost parentheses, so you end up with “&lt; (now)”. Using simplified syntax, the example looks like this:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="na">  [Mkay("&lt; (len .) 5", ErrorMessage = "That's too long, my friend.")]</span>
  <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

<span class="na">  [Mkay("&gt;= \"31.01.1900\"")]</span>
  <span class="k">public</span> <span class="n">DateTime</span> <span class="n">BirthDate</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

<span class="na">  [Mkay("&lt;= (now)")]</span>
  <span class="k">public</span> <span class="n">DateTime</span> <span class="n">DeathDate</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

<span class="na">  [Mkay("and (&gt;= BirthDate) (&lt;= DeathDate)")]</span>
  <span class="k">public</span> <span class="n">DateTime</span> <span class="n">LastSeen</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>So you can see that the sugar simplifies things quite a bit. Hopefully you’ll also agree that 1) the rules expressed in Mkay are more sophisticated than what the built-in validation attributes support, and 2) you’re pretty much free to write your own arbitrary rules using Mkay, without ever having to write a custom validation attribute again. The magic is back!</p>
<p>However, since this is a technical blog, let’s take a look under the covers to see how things work.</p>
<p>The crux of doing your own custom validation is to create a validation attribute that inherits from <strong>ValidationAttribute</strong> and implements <strong>IClientValidatable</strong>. Inheriting from <strong>ValidationAttribute</strong> is what lets us hook into the server-side validation process, whereas implementing <strong>IClientValidatable</strong> gives us a chance to send the necessary instructions to the browser to enable client-side validation. We’ll look at both of those things in turn. For now, though, let’s just concentrate on creating an instance of the validation attribute itself. In Mkay, the name of the validation attribute is <strong>MkayAttribute</strong>. No surprises there.</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="na">[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MkayAttribute</span> <span class="p">:</span> <span class="n">ValidationAttribute</span><span class="p">,</span> <span class="n">IClientValidatable</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="n">_ruleSource</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="n">_defaultErrorMessage</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">ConsCell</span><span class="p">&gt;</span> <span class="n">_cell</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">MkayAttribute</span><span class="p">(</span><span class="kt">string</span> <span class="n">ruleSource</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_ruleSource</span> <span class="p">=</span> <span class="n">ruleSource</span><span class="p">;</span>
    <span class="n">_defaultErrorMessage</span> <span class="p">=</span> <span class="s">"Respect '{0}', mkay?"</span><span class="p">.</span><span class="n">With</span><span class="p">(</span><span class="n">ruleSource</span><span class="p">);</span>
    <span class="n">_cell</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">ConsCell</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ExpParser</span><span class="p">(</span><span class="n">ruleSource</span><span class="p">).</span><span class="n">Parse</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">protected</span> <span class="n">ConsCell</span> <span class="n">Tree</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_cell</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ModelClientValidationRule</span><span class="p">&gt;</span> <span class="n">GetClientValidationRules</span><span class="p">(</span>
    <span class="n">ModelMetadata</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">ControllerContext</span> <span class="n">context</span><span class="p">)</span> <span class="err">…</span>

  <span class="k">protected</span> <span class="k">override</span> <span class="n">ValidationResult</span> <span class="nf">IsValid</span><span class="p">(</span>
    <span class="kt">object</span> <span class="k">value</span><span class="p">,</span> <span class="n">ValidationContext</span> <span class="n">validationContext</span><span class="p">)</span> <span class="err">…</span>
<span class="p">}</span>
</code></pre>
<p>The <strong>MkayAttribute</strong> constructor takes a single string parameter, which is supposed to contain a valid Mkay expression. Things will blow up at runtime if it doesn’t. The <strong>ExpParser</strong> class is responsible for parsing the Mkay expression into a suitable data structure known as an abstract syntax tree; AST for short. This happens lazily whenever someone tries to access the AST, which in practice means in the <strong>GetClientValidationRules</strong> and <strong>IsValid</strong> methods.</p>
<p>Due to LISP envy, <strong>ExpParser</strong> (simple as it is) uses lists and atoms as building blocks for the AST. Atoms represent simple things, such as a constant value (such as <em>10</em>), the name of a property (such as <strong>BirthDate</strong>) or a symbol representing some operation (such as &gt;). Lists are simply sequences of things, that is, sequences of lists and atoms. In Mkay, lists are built from so-called cons cells which are linked together in a chain. Each cons cell consists of two things, the first of which may be considered the content of the cell (a list or an atom), and the second of which is a reference to another cons cell or a special thing called <strong>Nil</strong>. So for instance, the Mkay expression “(&lt; (len .) 5)” is represented by the following AST:</p>
<p><img src="/images/e65ef73ada38/cons-cells.png" alt="Cons cells for an Mkay expression"></p>
<p>Once we have obtained the Mkay AST, we can use it to drive the client-side and server-side validations. This happens by subjecting the original AST to a two-pronged transformation process, to create two new, technology-specific AST’s: a .NET expression tree for the server-side validation code and a JSON structure for the client-side validation code. At the server side, the expression tree is compiled at runtime into a validation function that is immediately applied. The JSON structure, on the other hand, is sent to the browser where the jQuery validation machinery picks it up, and hands it over to what is essentially a validation function factory. So there’s code generation there, too, in a way, but it happens in the browser. Conceptually, the process looks like this:</p>
<p><img src="/images/7621b3fa8a69/mkay-overview.png" alt="The Mkay validation process"></p>
<p>Let’s look at server-side validation first. To participate in server-side validation, the <strong>MkayAttribute</strong> overrides the <strong>IsValid</strong> method inherited from <strong>ValidationAttribute</strong>. The implementation looks like this:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">protected</span> <span class="k">override</span> <span class="n">ValidationResult</span> <span class="nf">IsValid</span><span class="p">(</span><span class="kt">object</span> <span class="k">value</span><span class="p">,</span> 
  <span class="n">ValidationContext</span> <span class="n">validationContext</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">subject</span> <span class="p">=</span> <span class="n">validationContext</span><span class="p">.</span><span class="n">ObjectInstance</span><span class="p">;</span>
  <span class="kt">var</span> <span class="n">memName</span> <span class="p">=</span> <span class="n">validationContext</span><span class="p">.</span><span class="n">MemberName</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">memName</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span>
      <span class="s">"Property name is not set for property with display name "</span> 
      <span class="p">+</span> <span class="n">validationContext</span><span class="p">.</span><span class="n">DisplayName</span>
      <span class="p">+</span> <span class="s">", you should register the MkayValidator "</span>
      <span class="p">+</span> <span class="s">" with the MkayAttribute in global.asax."</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">var</span> <span class="n">validator</span> <span class="p">=</span> <span class="n">CreateValidator</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">memName</span><span class="p">,</span> <span class="n">Tree</span><span class="p">);</span>

  <span class="k">return</span> <span class="nf">validator</span><span class="p">()</span> 
    <span class="p">?</span> <span class="n">ValidationResult</span><span class="p">.</span><span class="n">Success</span> 
    <span class="p">:</span> <span class="k">new</span> <span class="n">ValidationResult</span><span class="p">(</span><span class="n">ErrorMessage</span> <span class="p">??</span> <span class="n">_defaultErrorMessage</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">static</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="n">CreateValidator</span><span class="p">(</span><span class="kt">object</span> <span class="n">subject</span><span class="p">,</span> 
  <span class="kt">string</span> <span class="n">property</span><span class="p">,</span> 
  <span class="n">ConsCell</span> <span class="n">ast</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ExpressionTreeBuilder</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">property</span><span class="p">);</span>
  <span class="kt">var</span> <span class="n">viz</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ExpVisitor</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">&gt;(</span><span class="n">builder</span><span class="p">);</span>
  <span class="n">ast</span><span class="p">.</span><span class="n">Accept</span><span class="p">(</span><span class="n">viz</span><span class="p">);</span>
  <span class="kt">var</span> <span class="n">exp</span> <span class="p">=</span> <span class="n">viz</span><span class="p">.</span><span class="n">GetResult</span><span class="p">();</span>
  <span class="kt">var</span> <span class="n">validator</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">DeriveFunc</span><span class="p">(</span><span class="n">exp</span><span class="p">).</span><span class="n">Compile</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">validator</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>As you can see, the method is passed two parameters, an object called value and a <strong>ValidationContext</strong> called context. The value parameter is the value of the property we’re validating. The <strong>ValidationContext</strong> provides – uh – context for the validation, such as a reference to the full object. That’s a good thing, otherwise we wouldn’t be able to access the values of other properties and our efforts would be futile! However, we’re not entirely out of trouble – for some reason, there is no easy way to obtain the name of the property value belongs to! I presume it’s just a silly oversight by the good ASP.NET MVC folks. In fact, there is actually a <strong>MemberName</strong> property on the <strong>ValidationContext</strong>, but it is always null! There is a <strong>DisplayName</strong> which is populated, but that doesn’t have to be unique and hence isn’t a reliable pathway back to the actual parameter.</p>
<p>So what to do, what to do? A brittle solution to this very surprising problem would be to use reflection to flip through stack frames and figure out which property the current instance of the <strong>MkayAttribute</strong> was used to annotate. I’m sure I could get it to work most of the time. However, there’s a much simpler solution. Since ASP.NET MVC is open source, we can quite literally go to the source to find the root of the problem. In doing so, we find that the problem can be traced back to the <strong>Validate</strong> method in the <strong>DataAnnotationsModelValidator</strong> class. For whatever reason, the <strong>ValidationContext.MemberName</strong> property is not set, even though it would be trivial to do so (like, right before or after <strong>DisplayName</strong> is set). Luckily, ASP.NET MVC is thoroughly configurable, and so it is entirely possible to substitute your own <strong>DataAnnotationsModelValidator</strong> for the default one. So that’s what Mkay does:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">MkayValidator</span> <span class="p">:</span> <span class="n">DataAnnotationsModelValidator</span><span class="p">&lt;</span><span class="n">MkayAttribute</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">MkayValidator</span><span class="p">(</span><span class="n">ModelMetadata</span> <span class="n">metadata</span><span class="p">,</span> 
    <span class="n">ControllerContext</span> <span class="n">context</span><span class="p">,</span> 
    <span class="n">MkayAttribute</span> <span class="n">attribute</span><span class="p">)</span>
    <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="k">public</span> <span class="k">override</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ModelValidationResult</span><span class="p">&gt;</span> <span class="n">Validate</span><span class="p">(</span><span class="kt">object</span> <span class="n">container</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">context</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ValidationContext</span><span class="p">(</span><span class="n">container</span> <span class="p">??</span> <span class="n">Metadata</span><span class="p">.</span><span class="n">Model</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span> 
      <span class="n">DisplayName</span> <span class="p">=</span> <span class="n">Metadata</span><span class="p">.</span><span class="n">GetDisplayName</span><span class="p">(),</span>
      <span class="n">MemberName</span> <span class="p">=</span> <span class="n">Metadata</span><span class="p">.</span><span class="n">PropertyName</span>
    <span class="p">};</span>

    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">Attribute</span><span class="p">.</span><span class="n">GetValidationResult</span><span class="p">(</span><span class="n">Metadata</span><span class="p">.</span><span class="n">Model</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">!=</span> <span class="n">ValidationResult</span><span class="p">.</span><span class="n">Success</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ModelValidationResult</span> <span class="p">{</span> <span class="n">Message</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="n">ErrorMessage</span> <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Finally, the ASP.NET MVC application must be configured to use the replacement validator class. This happens in the <strong>Application_Start</strong> method in the <strong>MvcApplication</strong> class, aka <em>global.asax</em>:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">MvcApplication</span> <span class="p">:</span> <span class="n">System</span><span class="p">.</span><span class="n">Web</span><span class="p">.</span><span class="n">HttpApplication</span>
<span class="p">{</span>
  <span class="k">protected</span> <span class="k">void</span> <span class="nf">Application_Start</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// … code omitted …</span>

    <span class="n">DataAnnotationsModelValidatorProvider</span><span class="p">.</span><span class="n">RegisterAdapter</span><span class="p">(</span>
      <span class="k">typeof</span><span class="p">(</span><span class="n">MkayAttribute</span><span class="p">),</span> 
      <span class="k">typeof</span><span class="p">(</span><span class="n">MkayValidator</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In case you forget to wire up the custom validator (which would be terribly silly of you), you’ll find that Mkay throws an exception complaining that the name of the property to validate hasn’t been set.</p>
<p>So we’re back on track, and we know the name of the property we’re trying to validate. Now all we have to do is to somehow transform the AST we built into .NET validation code that we can execute. To do so, we use expression trees. Expression trees allows us to programmatically build a data structure representing .NET code, and then magically transform it into executable code.</p>
<p>We use the venerable visitor pattern to walk the Mkay AST and build up the expression tree AST. The .NET framework offers factory methods for creating different kinds of expression nodes, such as <strong>Expression.Constant</strong> for creating a node that represents a constant value, <strong>Expression.And</strong> for the logical and operation, <strong>Expression.Add</strong> for plus and <strong>Expression.Call</strong> to represent a method call. The various methods naturally vary quite a bit with respect to what parameters they demand and the kind of expressions they return. For instance, <strong>Expression.And</strong> expects two <strong>Expression</strong> instances expected to be of type bool and returns an instance of <strong>BinaryExpression</strong>, also typed as bool. The various overloads of <strong>Expression.Call</strong>, on the other hand, return instances of <strong>MethodCallExpression</strong> and typically require a <strong>MethodInfo</strong> instance to identify the method to be called, as well as parameters to be passed to the method call. And so on and so forth. Pretty pedestrian stuff, nothing difficult.</p>
<p>It’s worth noting that you have to be careful and precise about types, though. For instance, the two sub-expressions passed to <strong>Expression.Add</strong> must be of the exact same type. An integer and a double cannot really be added together in a .NET program. However, if you add an integer and a double in a C# program, the compiler will make the necessary conversion for you (by turning the integer into a double). When using expression trees you need to handle such conversions manually. That is, you need to identify the type mismatch and see if you can resolve it by converting the type of one of the values into the type of the other. The general problem is known as unification in computer science and involves formulae that will make the head of the uninitiated hurt. However, Mkay takes a very simple approach by performing a lookup of available conversions for the types involved.</p>
<p>When expression tree has been built, we wrap things up by enveloping it in a lambda expression node of type <strong>Expression&lt;Func&lt;bool&gt;&gt;</strong>. This gives us access to a magical method called <strong>Compile</strong>. The <strong>Compile</strong> method is magical because it turns your expression tree into a validation method that can be executed. And of course that’s exactly what we do. If the state of the object is such that the validation method returns true, everything is well. Otherwise, we complain.</p>
<p><img src="/images/d8dcc7568e70/mkay-client-outline.png" alt="Outline for the Mkay client"></p>
<p>So as you can see, we have rock-solid server-side validation ensuring that we have short names and no suspicious deaths set in the future. We also happen to have a hard-coded earliest birth date, as well as a guarantee against zombies, but the screenshot doesn’t show that.</p>
<p>Now, let’s offer a superior user experience by doing the same checks client-side, as the user fills in the form. To do so, we must implement <strong>IClientValidatable</strong>, which in turn means we must implement a method called <strong>GetClientValidationRules</strong>.</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ModelClientValidationRule</span><span class="p">&gt;</span> <span class="n">GetClientValidationRules</span><span class="p">(</span>
    <span class="n">ModelMetadata</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">ControllerContext</span> <span class="n">context</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">propName</span> <span class="p">=</span> <span class="n">metadata</span><span class="p">.</span><span class="n">PropertyName</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">JsonBuilder</span><span class="p">(</span><span class="n">propName</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">visitor</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ExpVisitor</span><span class="p">&lt;</span><span class="n">JObject</span><span class="p">&gt;(</span><span class="n">builder</span><span class="p">);</span>
    <span class="n">Tree</span><span class="p">.</span><span class="n">Accept</span><span class="p">(</span><span class="n">visitor</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">ast</span> <span class="p">=</span> <span class="n">visitor</span><span class="p">.</span><span class="n">GetResult</span><span class="p">();</span>

    <span class="kt">var</span> <span class="n">json</span> <span class="p">=</span> <span class="k">new</span> <span class="n">JObject</span><span class="p">(</span>
      <span class="k">new</span> <span class="nf">JProperty</span><span class="p">(</span><span class="s">"rule"</span><span class="p">,</span> <span class="n">_ruleSource</span><span class="p">),</span> 
      <span class="k">new</span> <span class="nf">JProperty</span><span class="p">(</span><span class="s">"property"</span><span class="p">,</span> <span class="n">propName</span><span class="p">),</span>
      <span class="k">new</span> <span class="nf">JProperty</span><span class="p">(</span><span class="s">"ast"</span><span class="p">,</span> <span class="n">ast</span><span class="p">));</span>

    <span class="kt">var</span> <span class="n">rule</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ModelClientValidationRule</span>
      <span class="p">{</span>
        <span class="n">ErrorMessage</span> <span class="p">=</span> <span class="n">ErrorMessage</span> <span class="p">??</span> <span class="n">_defaultErrorMessage</span><span class="p">,</span> 
        <span class="n">ValidationType</span> <span class="p">=</span> <span class="s">"mkay"</span>
      <span class="p">};</span>

    <span class="n">rule</span><span class="p">.</span><span class="n">ValidationParameters</span><span class="p">[</span><span class="s">"rule"</span><span class="p">]</span> <span class="p">=</span> <span class="n">json</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>

    <span class="k">yield</span> <span class="k">return</span> <span class="n">rule</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>The string “mkay” that is set for the <strong>ValidationType</strong> is essentially a magic string that you need to match up on the JavaScript side. The same goes for the string “rule” that is used as a key for the <strong>ValidationParameters</strong> dictionary.</p>
<pre class="codehilite"><code class="language-javascript"><span></span><span class="nx">jQuery</span><span class="p">.</span><span class="nx">validator</span><span class="p">.</span><span class="nx">addMethod</span><span class="p">(</span><span class="s2">"mkay"</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">param</span><span class="p">)</span> <span class="p">{</span>
    <span class="s2">"use strict"</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">ruledata</span> <span class="o">=</span> <span class="nx">JSON</span> <span class="o">&amp;&amp;</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span> <span class="o">||</span> <span class="nx">$</span><span class="p">.</span><span class="nx">parseJSON</span><span class="p">(</span><span class="nx">param</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">validator</span> <span class="o">=</span> <span class="nx">MKAY</span><span class="p">.</span><span class="nx">getValidator</span><span class="p">(</span><span class="nx">ruledata</span><span class="p">.</span><span class="nx">rule</span><span class="p">,</span> <span class="nx">ruledata</span><span class="p">.</span><span class="nx">ast</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">validator</span><span class="p">();</span>
<span class="p">});</span>

<span class="nx">jQuery</span><span class="p">.</span><span class="nx">validator</span><span class="p">.</span><span class="nx">unobtrusive</span><span class="p">.</span><span class="nx">adapters</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s2">"mkay"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"rule"</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="s2">"use strict"</span><span class="p">;</span>
    <span class="nx">options</span><span class="p">.</span><span class="nx">rules</span><span class="p">.</span><span class="nx">mkay</span> <span class="o">=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">rule</span><span class="p">;</span>
    <span class="nx">options</span><span class="p">.</span><span class="nx">messages</span><span class="p">.</span><span class="nx">mkay</span> <span class="o">=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">message</span><span class="p">;</span>
<span class="p">});</span>
</code></pre>
<p>On the JavaScript side, we have to hook up our client-side validation code to the machinery that is called unobtrusive validation in jQuery. As you can see, the magic strings “mkay” and “rule” appear at various places in the code. Apart from the plumbing, nothing much happens here. A payload of JSON is picked up, deserialized, and passed to a validation function factory thing called <strong>MKAY.getValidator</strong>. That’s where the JSON AST is turned into an actual JavaScript function. First, though, let’s see an example of a JSON AST.</p>
<pre class="codehilite"><code class="language-json"><span></span><span class="p">{</span>
  <span class="nt">"type"</span><span class="p">:</span> <span class="s2">"call"</span><span class="p">,</span>
  <span class="nt">"value"</span><span class="p">:</span> <span class="s2">"&gt;"</span><span class="p">,</span>
  <span class="nt">"operands"</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">"type"</span><span class="p">:</span> <span class="s2">"property"</span><span class="p">,</span>
      <span class="nt">"value"</span><span class="p">:</span> <span class="s2">"X"</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">"type"</span><span class="p">:</span> <span class="s2">"call"</span><span class="p">,</span>
      <span class="nt">"value"</span><span class="p">:</span> <span class="s2">"+"</span><span class="p">,</span>
      <span class="nt">"operands"</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">"type"</span><span class="p">:</span> <span class="s2">"property"</span><span class="p">,</span>
          <span class="nt">"value"</span><span class="p">:</span> <span class="s2">"A"</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">"type"</span><span class="p">:</span> <span class="s2">"property"</span><span class="p">,</span>
          <span class="nt">"value"</span><span class="p">:</span> <span class="s2">"B"</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">"type"</span><span class="p">:</span> <span class="s2">"property"</span><span class="p">,</span>
          <span class="nt">"value"</span><span class="p">:</span> <span class="s2">"C"</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre>
<p>This example shows the JSON AST for the Mkay expression “(&gt; X (+ A B C))”. So in other words, the rule states that the value of X should be greater than the sum of A, B and C.</p>
<p>As we saw earlier, the deserialized JSON is passed to a validation function factory. The transformation process is conceptually pretty simple: every node in the JSON AST becomes a function. A function may be composed from simpler functions, or it may simply return a value, such as a string or an integer. The final validation function corresponds to the root node of the AST.</p>
<p>Let’s look at an example. Below, you see pseudo-code for the validation function produced from the JSON AST for the Mkay expression “(&gt; X (+ A B C))”.</p>
<pre class="codehilite"><code class="language-javascript"><span></span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">greater</span><span class="o">-</span><span class="nx">than</span><span class="o">-</span><span class="kd">function</span>
  <span class="p">(</span>
    <span class="nx">read</span><span class="o">-</span><span class="nx">property</span><span class="o">-</span><span class="kd">function</span><span class="p">(</span><span class="s2">"."</span><span class="p">),</span>
    <span class="nx">plus</span><span class="o">-</span><span class="kd">function</span><span class="p">(</span>
      <span class="nx">plus</span><span class="o">-</span><span class="kd">function</span><span class="p">(</span>
        <span class="nx">plus</span><span class="o">-</span><span class="kd">function</span><span class="p">(</span>
          <span class="mi">0</span><span class="p">,</span> 
          <span class="nx">read</span><span class="o">-</span><span class="nx">property</span><span class="o">-</span><span class="kd">function</span><span class="p">(</span><span class="s2">"C"</span><span class="p">)),</span>
        <span class="nx">read</span><span class="o">-</span><span class="nx">property</span><span class="o">-</span><span class="kd">function</span><span class="p">(</span><span class="s2">"B"</span><span class="p">)),</span>
      <span class="nx">read</span><span class="o">-</span><span class="nx">property</span><span class="o">-</span><span class="kd">function</span><span class="p">(</span><span class="s2">"A"</span><span class="p">))</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>It is pseudo-code because it shows function names that aren’t really there. I’ve included the names to make it easier to understand how functions are composed conceptually. In reality, the validation function consists exclusively of nested anonymous functions.</p>
<p>An important detail is that function arguments are evaluated lazily. That is, the arguments passed to functions are not values, they are themselves functions capable of returning a value. It is the responsibility of each individual function to actually call the argument functions to retrieve the argument values. Why is this? The reason is that every operation in client-side Mkay is implemented as a function, including the logical operators and and or. Since we want short-circuiting semantics for the logical operators, we only evaluate arguments as long as things go well.</p>
<pre class="codehilite"><code class="language-javascript"><span></span><span class="kd">function</span> <span class="nx">logical</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span> <span class="nx">breaker</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">copy</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">copy</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">copy</span><span class="p">.</span><span class="nx">pop</span><span class="p">()();</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">val</span> <span class="o">===</span> <span class="nx">breaker</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">breaker</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">!</span><span class="nx">breaker</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">and</span> <span class="o">=</span> <span class="nx">logical</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">;</span> <span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre>
<p>Here we see how the and function is implemented. The args parameter holds a list of functions that can be evaluated to a boolean value. We evaluate each function in turn, until we reach a function that evaluates to false or we’re done, in which case we return true.</p>
<p>Of course, all evaluations are postponed until we actually invoke the top-level validation function, in which case the evaluations necessary to reach a conclusion are carried out.</p>
<p>That’s all there is to it, really. Now we have client-side validation in Mkay. In practice, it might look like this:</p>
<p>And with that, we’re done. We’ll never have to write a custom validation attribute again, because Mkay is the one validation attribute to rule them all. The code is available <a href="https://github.com/einarwh/Mkay/">here</a>.</p>
<p><em>Update: Mkay is now available as a <a href="http://nuget.org/packages/mkay">nuget package</a>.</em></p>
</body></html>